---
title: "Multilevel analysis of directors data using JAGS"
author: "Jasper Ginn"
date: "April 8, 2019"
output:
  pdf_document: 
    number_sections: false
header-includes:
 \usepackage{float}
 \usepackage{setspace}
 \usepackage{xcolor}
 \definecolor{mypurple}{rgb}{146,76,239}
 \doublespacing
 \floatplacement{figure}{H}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.pos="H", fig.width = 7, fig.height = 4, echo = TRUE, 
                      fig.align="center", warning = FALSE, message = FALSE, eval=TRUE)
```

The **directors** dataset that is included with the `blm` library has a natural hierarchical structure with individuals nested in companies nested in industries nested in sectors. In this document, we will construct a multilevel model in JAGS using sectors, companies and individuals. Given that the data do not conform to the assumptions we need for a linear mixed-effect model, we will not run a full multilevel model (i.e. containing cross-level)

```{r load data}
rm(list=ls())
# Get the directors data
library(blm)
data("directors")

# Preprocess directors data
library(dplyr)
directors <- directors %>%
  # Log compensation
  mutate(Compensation = log(Compensation)) %>%
  # Subtract mean from Age variable
  mutate(Age = Age - mean(Age),
         Gend = as.numeric(Male)-1,
         Male = as.numeric(Male) - mean(as.numeric(Male))) %>%
  # Sort data (makes it easier later)
  arrange(Sector)
  
# Jags data
dir_jags <- with(directors, list(## Outcome for individuals (level 1)
  
                                 compensation = Compensation,
                                 # Age of individuals
                                 age=Age,
                                 # Gender of individuals
                                 gender=Male,
                                 # The sector that each individual belongs to
                                 sector_ind = as.numeric(as.factor(Sector)),
                                 
                                 ## Company-level variables (level 2)
                                 
                                 # Company indicator
                                 company=as.numeric(as.factor(Company)),
                                 # Average age of directors for each company
                                 avgAge=unname(tapply(Age, Company, mean)),
                                 # Proportion of males for each company
                                 avgMale=unname(tapply(Gend, Company, function(x) sum(x)/length(x))),
                                 
                                 ## Sector-level variables (level 3)
                                 
                                 # The sector that every company belongs to
                                 sector=directors %>% group_by(Company) %>% slice(1) %>%  
                                   ungroup() %>% select(Sector) %>% pull() %>% as.numeric(),
                                 
                                 ## Group totals
                                 
                                 # Number of individuals
                                 n=nrow(directors),  
                                 # Number of companies
                                 k=length(unique(Company)),
                                 # Number of sectors
                                 z=length(unique(Sector)),
                                 
                                 ## Number of predictors
                                 
                                 # Number of individual-level predictors
                                 p1=2,
                                 # Number of company-level predictors
                                 p2=2,
                                 # Number of sector-level predictors
                                 p3=0))
```

```{r simulated data, eval=FALSE, include=FALSE}
# Set seed
set.seed(501)

# Sample size (employees)
n <- 400
# Groups (companies)
k <- 10
# Sample companies
companies <- sample(1:k, n, replace=TRUE)

# Specify level 2 mean and variance (company level)
# That is, the mean of level 2: (in '000 dollars)
u_expected <- 120
u_sd <- 20
# Generate the group means using these numbers
u_companies <- rnorm(k, mean = u_expected, sd = u_sd)

# Specify level 1 intercept of each employee, depending on the company they work for
intcp <- matrix(0, nrow = n, ncol = k)
# Populate with 1 if employee belongs to company k
for (i in 1:n) {
  intcp[i, companies[i]] <- 1
}
# Create true intercept for employees
b0_true <- intcp %*% u_companies
# Create true slope for age
b1_true_age <- 2.2
# Generate data for age (sorted)
age <- sort(rnorm(n, mean=40, sd=5))
# True residual variance
sd_true <- 30
# Create the outcome variable y (compensation)
compensation <- rnorm(n, mean = b0_true + b1_true_age * age, sd = 10)

# To data frame
directors <- data.frame(Compensation = compensation, Age=age, Company=companies)

# Convert to JAGS format ----

# Jags data
dir_jags <- with(directors, list(compensation = Compensation, age=Age, company=Company,
                                  n=n, k=k))

```

```{r, eval=TRUE, fig.cap="Within and between variance of director compensation across companies"}
library(ggplot2)
library(forcats)
ggplot(directors, aes(x=fct_reorder(Company, as.numeric(Sector)), y=Compensation, color=Sector)) +
  geom_point() +
  geom_boxplot() +
  geom_hline(yintercept = mean(directors$Compensation)) +
  theme_blm() +
  scale_x_discrete(name = "Companies") +
  scale_y_continuous(name = "Compensation (logged)") +
  theme(legend.position="none",
        axis.text.x = element_blank())
```

From figure 1, it should be clear that the compensation variable across companies is not exactly normally distributed, but we will ignore that for now.

## The intercept-only model

The intercept-only model for the directors data is given by the following equations:

\begin{align}
\text{compensation}_{ij} = 
& \beta_{0j} + e_{ij} \tag{1} \\ 
\beta_{0j} =
& \gamma_{00} + u_{0j} \\
\text{compensation}_{ij} =
& \gamma_{00} + u_{0j} + e_{ij}
\end{align}

In words, this means we expect that a director's compensation is dependent on a grand mean over all sectors ($\gamma_{00}$) with some error term that captures the variation across sectors ($u_{0j}$) and an error term that captures variation across directors ($e_{ij}$).

Alternatively, we can specify the model as follows:

$$
\begin{aligned}
\text{compensation}_{ij} 
&\sim N(\beta_{0j}, \sigma^2_e) \\
\beta_{0j} 
&\sim N(\gamma_{00}, \sigma^2_{u_0}) \\
\gamma_{00} 
&\sim N(m_{00}, s_{00}^2) \\
\sigma^2_{u_0} 
&\sim IG(\alpha_{2_0}, \beta_{2_0}) \\
\sigma^2_e
&\sim IG(\alpha_{1}, \beta_{1})
\end{aligned}
$$

To run the model in JAGS, we construct the following code

```{r model 1 intercept-only model, eval=TRUE}
library(rjags)
library(tidyr)

if(!"model1.rds" %in% list.files()) {
  
  # Initial values
  dir_inits <- list(
    init1 <- list(tau=runif(1), tau_u0=runif(1), tau_v0=runif(1)),
    init2 <- list(tau=runif(1), tau_u0=runif(1), tau_v0=runif(1))
  )
  
  # Specify model in JAGS
  mod_io <- jags.model("1_intercept_only.txt", 
                       data = dir_jags,
                       inits = dir_inits,
                       n.chains=2)
  
  # Burn
  update(mod_io, n.iter=60000)
  
  # Draw samples
  params <- c("sigma_e", "sigma_u0", "sigma_v0", "zeta_00")
  # Run the chain
  resm1 <- coda.samples(mod_io, variable.names = params, n.iter=500000, thin = 10)
  
  # Save model
  saveRDS(resm1, "model1.rds")

  # DIC
  DICm1 <- dic.samples(mod_io, thin=5, n.iter=20000, type="pD")
  
  # Save
  saveRDS(DICm1, "model1_DIC.rds")

} else {
  
  resm1 <- readRDS(file="model1.rds")
  DICm1 <- readRDS(file="model1_DIC.rds")
  
}

# MAP values
MAPm1 <- apply(do.call(rbind.data.frame, resm1), 2, mean)

# Variance explained
vl3 <- MAPm1[3]^2 / sum(MAPm1[-4]^2) # 57.4%
vl2 <- MAPm1[2]^2 / sum(MAPm1[-4]^2)
vl1 <- 1-vl2 - vl3 # 42.6%
```

The values returned by JAGS allows us to calculate the *intraclass correlation coefficient*, defined as:

$$
\rho=\frac{\sigma^2_{u_0}}{\sigma^2_e + \sigma^2_{u_0} + \sigma^2_{v_0}}
$$

In the case of the directors data, the ICC equals `r unname(round(vl2, digits=3))`. This means:

1. That roughly $57.3\%$ of the variance can be found at the level 2 (company) variable.
2. That the expected correlation of two randomly picked directors in a given company is $\hat{r}=.573$.

Finally, we note that $0$ is not included in the credible interval of $\sigma^2_{u_0}$, which leads us to the conclusion that a multilevel model is appropriate. $(95\% \ \ \text{CCI}=[.321, .503])$.

## Level 1 variables

The second-level model is specified using the following mixed-model equation:

$$
\begin{aligned}
\text{compensation}_{ij} =
&\gamma_{00} + u_{0j} + \gamma_{10}\cdot \text{Age}_{ij} + \gamma_{20}\cdot \text{Male}_{ij} + e_{ij}
\end{aligned}
$$

or, equivalently:

$$
\begin{aligned}
\text{compensation}_{ij} 
&\sim N(\beta_{0j}, \sigma^2_e) \\
\beta_{0j} 
&\sim N(\gamma_{00}, \sigma^2_{u_0}) \\
\gamma_{00} 
&\sim N(m_{00}, s_{00}^2) \\
\gamma_{10}
&\sim N(m_{10}, s_{10}^2) \\
\gamma_{20}
&\sim N(m_{20}, s_{20}^2) \\
\sigma^2_{u_0} 
&\sim IG(\alpha_{2_0}, \beta_{2_0}) \\
\sigma^2_e
&\sim IG(\alpha_{1}, \beta_{1})
\end{aligned}
$$

```{r model2a level 1 predictors}
# Initial values
dir_inits <- list(
  init1 <- list(tau=runif(1), tau_u0=runif(1), tau_v0=runif(1)),
  init2 <- list(tau=runif(1), tau_u0=runif(1), tau_v0=runif(1))
)

if(!"model2.rds" %in% list.files()) {

  # Specify model in JAGS
  mod_io <- jags.model("2a_level_one_predictors.txt", 
                       data = dir_jags,
                       inits = dir_inits,
                       n.chains=2)
  
  # Burn
  update(mod_io, n.iter=60000)
  
  # Draw samples
  params <- c("sigma_e", "sigma_u0", "sigma_v0", "zeta_00", "zeta_10")
  # Run the chain
  resm2 <- coda.samples(mod_io, variable.names = params, n.iter=500000, thin = 10)
  
  # Save model
  saveRDS(resm2, "model2a.rds")
  
  # DIC
  DICm2 <- dic.samples(mod_io, thin=5, n.iter=20000, type="pD")
  
  # Save
  saveRDS(DICm2, "model2a_DIC.rds")
  
} else {
  
  resm2 <- readRDS(file="model2a.rds")
  DICm2 <- readRDS(file="model2a_DIC.rds")  
  
}
# MAP values
MAPm2 <- apply(do.call(rbind.data.frame, resm2), 2, mean)
```

We remove gender


- Little bit weird: error at level 2 went up? https://www.statmodel.com/download/Level-2%20R-square%20decreasing%20when%20adding%20level1-covariate.pdf

Explained variance at each level:

1. Level 1

$$
R^2_{L1} = \frac{\sigma^2_{e|\text{baseline}} - \sigma^2_{e|\text{model 1}}}{\sigma^2_{e|\text{baseline}}} = \frac{.2553 - .2504}{.2553} = 1.91\%
$$

2. Level 2

$$
R^2_{L2} = \frac{\sigma^2_{u_0|\text{baseline}} - \sigma^2_{u_0|\text{model 1}}}{\sigma^2_{u_0|\text{baseline}}} = \frac{.0936 - .0999}{.0936} = -6.73\%
$$

## Adding level-2 predictors

$$
\begin{aligned}
\text{compensation}_{ij} =
&\gamma_{00} + u_{0j} + \gamma_{10}\cdot \text{Age}_{ij} + \gamma_{01} \cdot \text{avgAge}_j + 
\gamma_{02} \cdot \text{propMale}_j + e_{ij}
\end{aligned}
$$

or, equivalently:

$$
\begin{aligned}
\text{compensation}_{ij} 
&\sim N(\beta_{0j}, \sigma^2_e) \\
\beta_{0j} 
&\sim N(\gamma_{00}, \sigma^2_{u_0}) \\
\gamma_{00} 
&\sim N(m_{00}, s_{00}^2) \\
\gamma_{10}
&\sim N(m_{10}, s_{10}^2) \\
\gamma_{02}
&\sim N(m_{02}, s_{02}^2) \\
\sigma^2_{u_0} 
&\sim IG(\alpha_{2_0}, \beta_{2_0}) \\
\sigma^2_e
&\sim IG(\alpha_{1}, \beta_{1})
\end{aligned}
$$

```{r model3 level 2 predictors}
# Initial values
dir_inits <- list(
  init1 <- list(tau=runif(1), tau_u0=runif(1), tau_v0=runif(1)),
  init2 <- list(tau=runif(1), tau_u0=runif(1), tau_v0=runif(1))
)

if(!"model3.rds" %in% list.files()) {

  # Specify model in JAGS
  mod_io <- jags.model("3_level_two_predictors.txt", 
                       data = dir_jags,
                       inits = dir_inits,
                       n.chains=2)
  
  # Burn
  update(mod_io, n.iter=60000)
  
  # Draw samples
  params <- c("sigma_e", "sigma_u0", "sigma_v0", "zeta_00", "zeta_10", "zeta_01")
  # Run the chain
  resm3 <- coda.samples(mod_io, variable.names = params, n.iter=500000, thin = 5)
  
  # DIC
  DICm3 <- dic.samples(mod_io, thin=5, n.iter=10000)
  
  # Save model
  saveRDS(resm3, "model3.rds")
  
  # Save
  saveRDS(DICm3, "model3_DIC.rds")

  
} else {
  
  
  
}

# MAP values
MAPm3 <- apply(do.call(rbind.data.frame, resm3), 2, mean)
```

Given that the level-2 variables are not significant (and that the model fit seems to worsen), we will not continue to build JAGS models from this point onwards. In fact, the best-fitting model we can conjure up is the intercept-only model (given that the model containing age is not explaining much of the variance). 

## Random coefficient model

$$
\begin{aligned}
\text{compensation}_{ij} =
&\gamma_{00} + u_{0j} + \gamma_{10}\cdot \text{Age}_{ij} + \gamma_{20} \cdot \text{Male}_{ij} + 
u_{1j}\cdot \text{Age}_{ij} + u_{2j} \cdot \text{Male}_{ij} + e_{ij}  
\end{aligned}
$$

or, equivalently:

$$
\begin{aligned}
\text{compensation}_{ij} 
&\sim N(\beta_{0j}, \sigma^2_e) \\
\beta_{0j} 
&\sim N(\gamma_{00}, \sigma^2_{u_0}) \\
\beta_{1j} 
&\sim N(\gamma_{10}, \sigma^2_{u_1}) \\
\beta_{2j} 
&\sim N(\gamma_{20}, \sigma^2_{u_2}) \\
\gamma_{00} 
&\sim N(m_{00}, s_{00}^2) \\
\gamma_{10}
&\sim N(m_{10}, s_{10}^2) \\
\gamma_{20}
&\sim N(m_{20}, s_{20}^2) \\
\sigma^2_{u_0} 
&\sim IG(\alpha_{2_0}, \beta_{2_0}) \\
\sigma^2_{u_1} 
&\sim IG(\alpha_{2_1}, \beta_{2_1}) \\
\sigma^2_{u_2} 
&\sim IG(\alpha_{2_2}, \beta_{2_2}) \\
\sigma^2_e
&\sim IG(\alpha_{1}, \beta_{1})
\end{aligned}
$$

```{r model4 random coef}
# Initial values
dir_inits <- list(
  init1 <- list(tau=runif(1), tau_u0=runif(1), tau_u1=runif(1), tau_u2=runif(1)),
  init2 <- list(tau=runif(1), tau_u0=runif(1), tau_u1=runif(1), tau_u2=runif(1))
)

# Specify model in JAGS
mod_io <- jags.model("4_random_coefficients.txt", 
                     data = dir_jags,
                     inits = dir_inits,
                     n.chains=2)

# Burn
update(mod_io, n.iter=60000)

# Draw samples
params <- c("sigma_e", "sigma_u0", "sigma_u1", "sigma_u2",
            "gamma_00", "gamma_10", "gamma_20")
# Run the chain
resm4 <- coda.samples(mod_io, variable.names = params, n.iter=500000, thin = 5)

# MAP values
MAPm4 <- apply(do.call(rbind.data.frame, resm4), 2, mean)

# DIC model 4
DICm4 <- dic.samples(mod_io, thin=5, n.iter=20000)
```

## The cross-level interaction

```{r model5 cross-level}
# Initial values
dir_inits <- list(
  init1 <- list(tau=runif(1), tau_u0=runif(1), tau_u1=runif(1), tau_u2=runif(1)),
  init2 <- list(tau=runif(1), tau_u0=runif(1), tau_u1=runif(1), tau_u2=runif(1))
)

# Specify model in JAGS
mod_io <- jags.model("5_cross_level_interaction.txt", 
                     data = dir_jags,
                     inits = dir_inits,
                     n.chains=2)

# Burn
update(mod_io, n.iter=60000)

# Draw samples
params <- c("sigma_e", "sigma_u0", "sigma_u1", "sigma_u2",
            "gamma_00", "gamma_10", "gamma_20", "gamma_01", "gamma_02",
            "gamma_21", "gamma_11", "gamma_22", "gamma_12")
# Run the chain
resm5 <- coda.samples(mod_io, variable.names = params, n.iter=800000, thin = 5)

# MAP values
MAPm5 <- apply(do.call(rbind.data.frame, resm5), 2, mean)

# All variance estimates > 0 so most likely significant
DICm5 <- dic.samples(mod_io, thin=5, n.iter=20000)
```

```{r model comparison}
# Table with DIC values
DICs <- data.frame(
  "DIC" = c(sum(DICm1$deviance + DICm1$penalty),
            sum(DICm2$deviance + DICm2$penalty),
            sum(DICm3$deviance + DICm3$penalty),
            sum(DICm4$deviance + DICm4$penalty),
            sum(DICm5$deviance + DICm5$penalty)),
  row.names = c("Intercept-only", "Predictors level 1",
                "Predictors levels 1 + 2", "Random coefficient",
                "Cross-level interaction")
)
# Cat
knitr::kable(DICs)
```


```{r}
# Results from model 3
final_mod <- do.call(rbind.data.frame, resm3)

```

# References

Lynch, S. M. (2007). Introduction to applied Bayesian statistics and estimation for social scientists. Springer Science & Business Media. Chapter 9.2

Aarts, E. (2019). Introduction to multilevel analysis and the basic two-level regression model, week 1 notes [powerpoint presentation]. *Introduction to Multilevel Analysis*, Utrecht University.
